/**
 * NXMLPanelRenderer - Renders NXML panels with full Nexus integration
 *
 * This component:
 * - Parses NXML source into an AST using nexus-reactor
 * - Creates a runtime panel instance in workspace-kernel
 * - Connects via WebSocket for real-time state sync
 * - Renders the panel UI using nexus-reactor hydrator
 * - Handles tool execution through workspace-kernel
 */

import React, { useEffect, useState, useCallback, useRef } from 'react';
import { useNexusClient, usePanelWebSocket, usePanelState } from '../context/NexusContext';
import { NexusReactor } from '@nexus/reactor';

export interface NXMLPanelRendererProps {
  /**
   * NXML source code to render
   */
  nxmlSource: string;

  /**
   * Initial state for the panel (optional)
   */
  initialState?: Record<string, any>;

  /**
   * Panel ID (if already created, otherwise will create new)
   */
  panelId?: string;

  /**
   * Callback when panel is created
   */
  onPanelCreated?: (panelId: string) => void;

  /**
   * Callback when panel state changes
   */
  onStateChange?: (state: Record<string, any>) => void;

  /**
   * Callback when an error occurs
   */
  onError?: (error: Error) => void;

  /**
   * CSS class name
   */
  className?: string;

  /**
   * Inline styles
   */
  style?: React.CSSProperties;
}

/**
 * NXML Panel Renderer Component
 */
export function NXMLPanelRenderer({
  nxmlSource,
  initialState,
  panelId: providedPanelId,
  onPanelCreated,
  onStateChange,
  onError,
  className,
  style,
}: NXMLPanelRendererProps) {
  const client = useNexusClient();
  const [panelId, setPanelId] = useState<string | null>(providedPanelId || null);
  const [isCreating, setIsCreating] = useState(false);
  const [createError, setCreateError] = useState<Error | null>(null);
  const [reactor, setReactor] = useState<NexusReactor | null>(null);
  const [isInitializing, setIsInitializing] = useState(true);
  const reactorRef = useRef<NexusReactor | null>(null);
  const [isPanelVerified, setIsPanelVerified] = useState(false);
  const [hasRetriedCreation, setHasRetriedCreation] = useState(false);

  // WebSocket connection (for NOG sync and cross-panel communication)
  // Only connect after panel is verified to exist on server
  const { isConnected, error: wsError } = usePanelWebSocket(panelId, isPanelVerified && !!panelId);

  // Remote panel state (for persistence)
  const { state: remoteState, isLoading: isLoadingState, error: stateError } = usePanelState(isPanelVerified ? panelId : null);

  /**
   * Create or verify panel exists on server
   * If providedPanelId is given, verify it exists first; if not, recreate it
   */
  useEffect(() => {
    if (isCreating) return;

    const createOrVerifyPanel = async () => {
      setIsCreating(true);
      setCreateError(null);

      try {
        // If panel ID is provided, check if it exists on server first
        if (providedPanelId && panelId) {
          try {
            await client.getPanelInfo(panelId);
            console.log('[NXMLPanelRenderer] Panel exists:', panelId);
            // Panel exists, no need to create
            setIsPanelVerified(true);
            setIsCreating(false);
            return;
          } catch {
            // Panel doesn't exist on server, need to recreate
            console.log('[NXMLPanelRenderer] Panel not found on server, recreating:', panelId);
          }
        }

        // Create new panel (or recreate if it didn't exist)
        const response = await client.createPanelFromNXML(nxmlSource, initialState || {});
        console.log('[NXMLPanelRenderer] Panel created:', response.id);
        setPanelId(response.id);
        setIsPanelVerified(true);
        onPanelCreated?.(response.id);
        setCreateError(null);
      } catch (err) {
        console.error('[NXMLPanelRenderer] Failed to create panel:', err);
        const error = err instanceof Error ? err : new Error(String(err));
        setCreateError(error);
        onError?.(error);
      } finally {
        setIsCreating(false);
      }
    };

    // Only run if we need to create or verify a panel
    if (!panelId || (providedPanelId && !hasRetriedCreation)) {
      if (providedPanelId && !hasRetriedCreation) {
        setHasRetriedCreation(true);
      }
      createOrVerifyPanel();
    }
  }, [providedPanelId, panelId, isCreating, hasRetriedCreation, nxmlSource, initialState, client, onPanelCreated, onError]);

  /**
   * Notify parent of state changes
   * Use a ref to track previous state and avoid infinite loops
   */
  const prevRemoteStateRef = useRef<string | null>(null);
  useEffect(() => {
    if (remoteState && onStateChange) {
      const stateJson = JSON.stringify(remoteState);
      // Only notify if state actually changed
      if (prevRemoteStateRef.current !== stateJson) {
        prevRemoteStateRef.current = stateJson;
        onStateChange(remoteState);
      }
    }
  }, [remoteState, onStateChange]);

  /**
   * Report errors
   */
  useEffect(() => {
    const error = createError || wsError || stateError;
    if (error && onError) {
      onError(error);
    }
  }, [createError, wsError, stateError, onError]);

  /**
   * Initialize NexusReactor when panel is ready
   */
  useEffect(() => {
    // Only initialize if we have the required data and haven't already initialized
    if (!nxmlSource || !panelId || reactor) return;

    const initReactor = async () => {
      try {
        console.log('[NXMLPanelRenderer] Initializing reactor for panel:', panelId);

        // Create reactor instance
        const newReactor = new NexusReactor({
          source: nxmlSource,
          initialState: initialState || remoteState || {},
        });

        // Mount reactor (runs mount lifecycle)
        await newReactor.mount();

        console.log('[NXMLPanelRenderer] Reactor mounted successfully');
        setReactor(newReactor);
        reactorRef.current = newReactor;
        setIsInitializing(false);
      } catch (error) {
        console.error('[NXMLPanelRenderer] Failed to initialize reactor:', error);
        // Log detailed validation errors if available
        if ((error as any)?.errors) {
          console.error('[NXMLPanelRenderer] Validation errors:', (error as any).errors);
        }
        if ((error as any)?.warnings) {
          console.warn('[NXMLPanelRenderer] Validation warnings:', (error as any).warnings);
        }
        const err = error instanceof Error ? error : new Error(String(error));
        setCreateError(err);
        onError?.(err);
        setIsInitializing(false);
      }
    };

    initReactor();

    // Cleanup reactor on unmount
    return () => {
      if (reactorRef.current) {
        console.log('[NXMLPanelRenderer] Unmounting reactor');
        reactorRef.current.unmount();
        reactorRef.current = null;
      }
    };
  }, [nxmlSource, panelId, reactor, initialState, remoteState, onError]);

  /**
   * Sync remote state changes to reactor
   */
  useEffect(() => {
    if (reactor && remoteState && JSON.stringify(reactor.state.proxy) !== JSON.stringify(remoteState)) {
      console.log('[NXMLPanelRenderer] Syncing remote state to reactor');
      // Update reactor state with remote changes
      Object.assign(reactor.state.proxy, remoteState);
    }
  }, [reactor, remoteState]);

  /**
   * Cleanup on unmount
   */
  useEffect(() => {
    return () => {
      if (panelId && !providedPanelId) {
        // Only delete if we created it (not provided externally)
        console.log('[NXMLPanelRenderer] Cleaning up panel:', panelId);
        client.deletePanel(panelId).catch((err) => {
          console.error('[NXMLPanelRenderer] Failed to delete panel:', err);
        });
      }
    };
  }, [panelId, providedPanelId, client]);

  /**
   * Render loading state
   */
  if (isCreating) {
    return (
      <div className={className} style={{ padding: '2rem', textAlign: 'center', ...style }}>
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-violet-500 mx-auto mb-2" />
        <p className="text-sm text-zinc-400">Creating panel...</p>
      </div>
    );
  }

  /**
   * Render error state
   */
  if (createError || wsError || stateError) {
    const error = createError || wsError || stateError;
    return (
      <div
        className={className}
        style={{
          padding: '2rem',
          backgroundColor: 'rgba(220, 38, 38, 0.1)',
          border: '1px solid rgba(220, 38, 38, 0.3)',
          borderRadius: '0.5rem',
          ...style,
        }}
      >
        <h3 className="text-red-400 font-semibold mb-2">Panel Error</h3>
        <p className="text-sm text-red-300">{error?.message}</p>

        {/* Show detailed validation errors if available */}
        {(error as any)?.errors && (
          <div className="mt-3">
            <h4 className="text-red-400 text-xs font-semibold mb-1">Validation Errors:</h4>
            {(error as any).errors.map((err: any, idx: number) => (
              <div key={idx} className="mt-2 p-2 bg-red-900/20 rounded text-xs">
                <div className="text-red-300 font-mono">[{err.code}] {err.message}</div>
                {err.path && (
                  <div className="text-red-400/70 mt-1">Path: {err.path.join(' > ')}</div>
                )}
                {err.loc && (
                  <div className="text-red-400/70">
                    Line {err.loc.startLine}, Column {err.loc.startColumn}
                  </div>
                )}
              </div>
            ))}
          </div>
        )}

        {/* Show warnings if available */}
        {(error as any)?.warnings && (error as any).warnings.length > 0 && (
          <div className="mt-3">
            <h4 className="text-yellow-400 text-xs font-semibold mb-1">Warnings:</h4>
            {(error as any).warnings.map((warn: any, idx: number) => (
              <div key={idx} className="mt-2 p-2 bg-yellow-900/20 rounded text-xs">
                <div className="text-yellow-300 font-mono">[{warn.code}] {warn.message}</div>
                {warn.path && (
                  <div className="text-yellow-400/70 mt-1">Path: {warn.path.join(' > ')}</div>
                )}
              </div>
            ))}
          </div>
        )}

        <details className="mt-2">
          <summary className="text-xs text-red-400 cursor-pointer">Stack Trace</summary>
          <pre className="text-xs text-red-300 mt-1 overflow-auto">{error?.stack}</pre>
        </details>
      </div>
    );
  }

  /**
   * Render connecting state
   */
  if (!isConnected && panelId) {
    return (
      <div className={className} style={{ padding: '2rem', textAlign: 'center', ...style }}>
        <div className="animate-pulse">
          <div className="h-2 bg-violet-500/30 rounded w-3/4 mx-auto mb-2" />
          <div className="h-2 bg-violet-500/20 rounded w-1/2 mx-auto" />
        </div>
        <p className="text-sm text-zinc-400 mt-4">Connecting to panel...</p>
      </div>
    );
  }

  /**
   * Render loading state
   */
  if (isLoadingState) {
    return (
      <div className={className} style={{ padding: '2rem', textAlign: 'center', ...style }}>
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-violet-500 mx-auto mb-2" />
        <p className="text-sm text-zinc-400">Loading panel state...</p>
      </div>
    );
  }

  /**
   * Render initializing state
   */
  if (isInitializing) {
    return (
      <div className={className} style={{ padding: '2rem', textAlign: 'center', ...style }}>
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-violet-500 mx-auto mb-2" />
        <p className="text-sm text-zinc-400">Initializing panel...</p>
      </div>
    );
  }

  /**
   * Render the actual panel with nexus-reactor
   */
  if (reactor) {
    const PanelComponent = reactor.getComponent();

    return (
      <div className={className} style={{ height: '100%', display: 'flex', flexDirection: 'column', ...style }}>
        {/* Panel Header with connection status */}
        <div className="flex items-center justify-between px-4 py-2 border-b border-white/10 bg-zinc-900/50 flex-shrink-0">
          <div className="flex items-center gap-2">
            <div
              className={`w-2 h-2 rounded-full ${isConnected ? 'bg-green-500' : 'bg-yellow-500'}`}
              title={isConnected ? 'Connected' : 'Connecting...'}
            />
            <span className="text-sm text-zinc-400">Panel: {panelId?.slice(0, 8)}...</span>
          </div>
        </div>

        {/* Panel Content - Rendered by nexus-reactor */}
        <div className="flex-1 overflow-auto">
          <PanelComponent />
        </div>
      </div>
    );
  }

  /**
   * Fallback: Should not reach here
   */
  return (
    <div className={className} style={{ padding: '2rem', textAlign: 'center', ...style }}>
      <p className="text-sm text-zinc-400">Panel not ready</p>
    </div>
  );
}

/**
 * Hook to use NXML panel renderer programmatically
 */
export function useNXMLPanel(nxmlSource: string, initialState?: Record<string, any>) {
  const client = useNexusClient();
  const [panelId, setPanelId] = useState<string | null>(null);
  const [error, setError] = useState<Error | null>(null);
  const [isCreating, setIsCreating] = useState(false);

  const createPanel = useCallback(async () => {
    setIsCreating(true);
    setError(null);

    try {
      const response = await client.createPanel({
        nxmlSource,
        initialState,
      });
      setPanelId(response.id);
      return response.id;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      throw error;
    } finally {
      setIsCreating(false);
    }
  }, [client, nxmlSource, initialState]);

  const destroyPanel = useCallback(async () => {
    if (panelId) {
      await client.deletePanel(panelId);
      setPanelId(null);
    }
  }, [client, panelId]);

  useEffect(() => {
    return () => {
      if (panelId) {
        destroyPanel().catch(console.error);
      }
    };
  }, [panelId, destroyPanel]);

  return {
    panelId,
    createPanel,
    destroyPanel,
    isCreating,
    error,
  };
}
